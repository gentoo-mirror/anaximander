--- xrayutilities/config.py	(original)
+++ xrayutilities/config.py	(refactored)
@@ -29,7 +29,7 @@
 try:
     import configparser
 except ImportError:
-    import ConfigParser as configparser
+    import configparser as configparser
 
 from . import __path__
 from . import utilities_noconf
--- xrayutilities/experiment.py	(original)
+++ xrayutilities/experiment.py	(refactored)
@@ -88,7 +88,7 @@
                         (default: identity matrix)
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['wl','en','UB']:
                 raise Exception("unknown keyword argument given: allowed are 'en': for x-ray energy, 'wl': x-ray wavelength, 'UB': orientation/orthonormalization matrix")
         
@@ -153,13 +153,13 @@
          sampleAxis:     list or tuple of sample circles, e.g. ['x+','z+']
         """
 
-        if isinstance(sampleAxis,(basestring,list,tuple)):
-            if isinstance(sampleAxis,basestring):
+        if isinstance(sampleAxis,(str,list,tuple)):
+            if isinstance(sampleAxis,str):
                 sAxis = list([sampleAxis])
             else:
                 sAxis = list(sampleAxis)
             for circ in sAxis:
-                if not isinstance(circ,basestring) or len(circ)!=2:
+                if not isinstance(circ,str) or len(circ)!=2:
                     raise InputError("QConversion: incorrect sample circle type or syntax (%s)" %repr(circ))
                 if not circleSyntaxSample.search(circ):
                     raise InputError("QConversion: incorrect sample circle syntax (%s)" %circ)
@@ -232,13 +232,13 @@
          detrot:           flag to tell that the detector rotation is going to be added
                            (used internally to avoid double adding of detector rotation axis)
         """
-        if isinstance(detectorAxis,(basestring,list,tuple)):
-            if isinstance(detectorAxis,basestring):
+        if isinstance(detectorAxis,(str,list,tuple)):
+            if isinstance(detectorAxis,str):
                 dAxis = list([detectorAxis])
             else:
                 dAxis = list(detectorAxis)
             for circ in dAxis:
-                if not isinstance(circ,basestring) or len(circ)!=2:
+                if not isinstance(circ,str) or len(circ)!=2:
                     raise InputError("QConversion: incorrect detector circle type or syntax (%s)" %repr(circ))
                 if not circleSyntax.search(circ):
                     raise InputError("QConversion: incorrect detector circle syntax (%s)" %circ)
@@ -352,7 +352,7 @@
         where * corresponds to the number of points given in the input
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['wl','deg','UB','delta']:
                 raise Exception("unknown keyword argument given: allowed are 'delta': angle offsets, 'wl': x-ray wavelength, 'UB': orientation/orthonormalization matrix, 'deg': flag to tell if angles are in degrees")
         
@@ -475,12 +475,12 @@
           roi:           region of interest for the detector pixels; e.g. [100,900]
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['Nav','roi']:
                 raise Exception("unknown keyword argument given: allowed are 'Nav': number of channels for block-average, 'roi': region of interest")
         
         # detectorDir
-        if not isinstance(detectorDir,basestring) or len(detectorDir)!=2:
+        if not isinstance(detectorDir,str) or len(detectorDir)!=2:
             raise InputError("QConversion: incorrect detector direction type or syntax (%s)" %repr(detectorDir))
         if not circleSyntax.search(detectorDir):
             raise InputError("QConversion: incorrect detector direction syntax (%s)" %detectorDir)
@@ -554,7 +554,7 @@
         if not self._linear_init:
             raise Exception("QConversion: linear detector not initialized -> call Ang2Q.init_linear(...)")
         
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['wl','deg','UB','delta','Nav','roi']:
                 raise Exception("unknown keyword argument given: allowed are 'delta': angle offsets, 'wl': x-ray wavelength, 'UB': orientation/orthonormalization matrix, 'deg': flag to tell if angles are in degrees, 'Nav': number of channels for block-averaging, 'roi': region of interest")
 
@@ -699,17 +699,17 @@
           roi:            region of interest for the detector pixels; e.g. [100,900,200,800]
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['Nav','roi']:
                 raise Exception("unknown keyword argument given: allowed are 'Nav': number of channels for block-average, 'roi': region of interest")
         
         # detectorDir
-        if not isinstance(detectorDir1,basestring) or len(detectorDir1)!=2:
+        if not isinstance(detectorDir1,str) or len(detectorDir1)!=2:
             raise InputError("QConversion: incorrect detector direction1 type or syntax (%s)" %repr(detectorDir1))
         if not circleSyntax.search(detectorDir1):
             raise InputError("QConversion: incorrect detector direction1 syntax (%s)" %detectorDir1)
         self._area_detdir1 = detectorDir1
-        if not isinstance(detectorDir2,basestring) or len(detectorDir2)!=2:
+        if not isinstance(detectorDir2,str) or len(detectorDir2)!=2:
             raise InputError("QConversion: incorrect detector direction2 type or syntax (%s)" %repr(detectorDir2))
         if not circleSyntax.search(detectorDir2):
             raise InputError("QConversion: incorrect detector direction2 syntax (%s)" %detectorDir2)
@@ -801,7 +801,7 @@
         if not self._area_init:
             raise Exception("QConversion: area detector not initialized -> call Ang2Q.init_area(...)")
         
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['wl','deg','UB','delta','Nav','roi']:
                 raise Exception("unknown keyword argument given: allowed are 'delta': angle offsets, 'wl': x-ray wavelength, 'UB': orientation/orthonormalization matrix, 'deg': flag to tell if angles are in degrees, 'Nav': number of channels for block-averaging, 'roi': region of interest")
 
@@ -953,7 +953,7 @@
                      the en keyword overrulls the wl keyword
         """
 
-        for k in keyargs.keys():
+        for k in list(keyargs.keys()):
             if k not in ['qconv','wl','en']:
                 raise Exception("unknown keyword argument given: allowed are 'en': for x-ray energy, 'wl': x-ray wavelength, 'qconv': reciprocal space conversion.")
 
@@ -1118,7 +1118,7 @@
 
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['U','B','mat','dettype']:
                 raise Exception("unknown keyword argument given: allowed are 'B': orthonormalization matrix, 'U': orientation matrix, 'mat': material object, 'dettype': string with detector type")
         
@@ -1325,7 +1325,7 @@
          pdi_d: offset ot the diffracted beam from the scattering plane due to refraction
         """
 
-        for k in keyargs.keys():
+        for k in list(keyargs.keys()):
             if k not in ['trans','deg','geometry','refrac','mat','fi','fd','full_output']:
                 raise Exception("unknown keyword argument given: see documentation for details")
         
@@ -1586,7 +1586,7 @@
          twotheta:   scattering angle (detector)
         """
 
-        for k in keyargs.keys():
+        for k in list(keyargs.keys()):
             if k not in ['trans','deg']:
                 raise Exception("unknown keyword argument given: allowed are 'trans': coordinate transformation flag, 'deg': degree-flag")
         
@@ -1730,7 +1730,7 @@
          beta:       exit angle from surface (at the moment always 0)
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['trans','deg']:
                 raise Exception("unknown keyword argument given: allowed are 'trans': coordinate transformation flag, 'deg': degree-flag")
         
@@ -1891,7 +1891,7 @@
          gamma:    scattering angle
         """
 
-        for k in kwargs.keys():
+        for k in list(kwargs.keys()):
             if k not in ['trans','deg']:
                 raise Exception("unknown keyword argument given: allowed are 'trans': coordinate transformation flag, 'deg': degree-flag")
         
--- xrayutilities/normalize.py	(original)
+++ xrayutilities/normalize.py	(refactored)
@@ -178,7 +178,7 @@
         >>> detcorr = IntensityNormalizer(det="MCA",time="Seconds",absfun=lambda d: d["PSDCORR"]/d["PSD"].astype(numpy.float))
         """
 
-        for k in keyargs.keys():
+        for k in list(keyargs.keys()):
             if k not in ['mon','time','smoothmon','av_mon','absfun','flatfield','darkfield']:
                 raise Exception("unknown keyword argument given: allowed are 'mon', 'smoothmon', 'av_mon', 'absfun', 'flatfield' and 'darkfield'")
         
@@ -232,7 +232,7 @@
         det  property handler
         sets the detector field name
         """
-        if isinstance(det,basestring):
+        if isinstance(det,str):
             self._det = det
         else:
             self._det = None
@@ -251,7 +251,7 @@
         time property handler
         sets the count time field or value
         """
-        if isinstance(time,basestring):
+        if isinstance(time,str):
             self._time = time
         elif isinstance(time,(float,int)):
             self._time = float(time)
@@ -272,7 +272,7 @@
         mon property handler
         sets the monitor field name
         """
-        if isinstance(mon,basestring):
+        if isinstance(mon,str):
             self._mon = mon
         elif isinstance(mon,type(None)):
             self._mon = None
@@ -395,7 +395,7 @@
         else:
             mon = 1.
         # count time
-        if isinstance(self._time,basestring):
+        if isinstance(self._time,str):
             time = data[self._time]
         elif isinstance(self._time,float):
             time = self._time
--- xrayutilities/utilities_noconf.py	(original)
+++ xrayutilities/utilities_noconf.py	(refactored)
@@ -78,7 +78,7 @@
 
     if numpy.isreal(en):
         return numpy.double(en)
-    elif isinstance(en,basestring):
+    elif isinstance(en,str):
         return energies[en]
     else:
         raise InputError("wrong type for argument en")
@@ -104,7 +104,7 @@
 
     if numpy.isreal(wl):
         return numpy.double(wl)
-    elif isinstance(wl,basestring):
+    elif isinstance(wl,str):
         return lam2en(energies[wl])
     else:
         raise InputError("wrong type for argument wavelength")
--- xrayutilities/io/edf.py	(original)
+++ xrayutilities/io/edf.py	(refactored)
@@ -153,19 +153,19 @@
                         self.header[key] = value
 
         # try to parse motor positions and counters from header into separate dictionary
-        if 'motor_mne' in self.header.keys():
+        if 'motor_mne' in list(self.header.keys()):
             tkeys = self.header['motor_mne'].split()
             try: 
                 tval = numpy.array(self.header['motor_pos'].split(),dtype=numpy.double)
-                self.motors = dict(zip(tkeys,tval))
+                self.motors = dict(list(zip(tkeys,tval)))
             except:
                 print("XU.io.EDFFile.ReadData: Warning: header conversion of motor positions failed")
 
-        if 'counter_mne' in self.header.keys():
+        if 'counter_mne' in list(self.header.keys()):
             tkeys = self.header['counter_mne'].split()
             try: 
                 tval = numpy.array(self.header['counter_pos'].split(),dtype=numpy.double)
-                self.counters = dict(zip(tkeys,tval))
+                self.counters = dict(list(zip(tkeys,tval)))
             except:
                 print("XU.io.EDFFile.ReadData: Warning: header conversion of counter values failed")
 
@@ -299,7 +299,7 @@
         ca[...] = self.data[...]
 
         #finally we have to append the attributes
-        for k in self.header.keys():
+        for k in list(self.header.keys()):
             aname = k.replace(".","_")
             aname = aname.replace(" ","_")
             ca.attrs.__setattr__(aname,self.header[k])
--- xrayutilities/io/panalytical_xml.py	(original)
+++ xrayutilities/io/panalytical_xml.py	(refactored)
@@ -114,12 +114,12 @@
                         is_scalar = 0
 
         #finally all scan data needs to be converted to numpy arrays
-        for k in self.ddict.keys():
+        for k in list(self.ddict.keys()):
             self.ddict[k] = numpy.array(self.ddict[k])
 
         #flatten output if only one scan was present
         if len(slist) == 1:
-            for k in self.ddict.keys():
+            for k in list(self.ddict.keys()):
                 self.ddict[k] = numpy.ravel(self.ddict[k])
 
     def __getitem__(self,key):
@@ -127,7 +127,7 @@
 
     def __str__(self):
         ostr = "XRDML Measurement\n"
-        for k in self.ddict.keys():
+        for k in list(self.ddict.keys()):
             ostr += "%s with %s points\n" %(k,str(self.ddict[k].shape))
 
         return ostr
--- xrayutilities/io/rotanode_alignment.py	(original)
+++ xrayutilities/io/rotanode_alignment.py	(refactored)
@@ -206,7 +206,7 @@
 
         # get number aligned axis for the current peak
         axnames = []
-        for k in self.keys():
+        for k in list(self.keys()):
             if k.find(pname)>=0:
                 axnames.append(k)
 
--- xrayutilities/io/seifert.py	(original)
+++ xrayutilities/io/seifert.py	(refactored)
@@ -80,7 +80,7 @@
 
     def __str__(self):
         ostr = ""
-        for k in self.__dict__.keys():
+        for k in list(self.__dict__.keys()):
             value = self.__getattribute__(k)
             if isinstance(value,float):
                 ostr += k + " = %f\n" %value
@@ -90,7 +90,7 @@
         return ostr
 
     def save_h5_attribs(self,obj):
-        for a in self.__dict__.keys():
+        for a in list(self.__dict__.keys()):
             value = self.__getattribute__(a)
             obj._v_attrs.__setattr__(a,value)
 
--- xrayutilities/io/spec.py	(original)
+++ xrayutilities/io/spec.py	(refactored)
@@ -511,7 +511,7 @@
         g._v_attrs.Time = self.time
 
         #write the initial motor positions as attributes
-        for k in self.init_motor_pos.keys():
+        for k in list(self.init_motor_pos.keys()):
             g._v_attrs.__setattr__(k,numpy.float(self.init_motor_pos[k]))
 
         #if scan contains MCA data write also MCA parameters
@@ -519,7 +519,7 @@
         g._v_attrs.mca_stop_channel = numpy.uint(self.mca_stop_channel)
         g._v_attrs.mca_nof_channels = numpy.uint(self.mca_channels)
 
-        for k in optattrs.keys():
+        for k in list(optattrs.keys()):
             g._v_attrs.__setattr__(k,opattrs[k])
 
         h5.flush()
@@ -973,7 +973,7 @@
         scanlist = list([scans])
 
     angles = dict.fromkeys(args)
-    for key in angles.keys():
+    for key in list(angles.keys()):
         if not isinstance(key,str):
             raise InputError("*arg values need to be strings with motornames")
         angles[key] = numpy.zeros(0)
--- xrayutilities/io/spectra.py	(original)
+++ xrayutilities/io/spectra.py	(refactored)
@@ -79,13 +79,13 @@
 
     def __str__(self):
         ostr = ""
-        n = len(self.keys())
+        n = len(list(self.keys()))
         lmax_key = 0
         lmax_item = 0
         strlist = []
 
         #find the length of the longest key
-        for k in self.keys():
+        for k in list(self.keys()):
             if len(k)>lmax_key: lmax_key = len(k)
 
             i = self[k]
@@ -99,14 +99,14 @@
         kvfmt = "|%%-%is = %%-%is" %(lmax_key,lmax_item)
 
         nc = 3
-        nres = len(self.keys())%nc
-        nrow = (len(self.keys())-nres)/nc
+        nres = len(list(self.keys()))%nc
+        nrow = (len(list(self.keys()))-nres)/nc
 
         cnt = 0
         ostr += (3*(lmax_key+lmax_item+4)+1)*"-"+"\n"
         ostr += "|Parameters:" +(3*(lmax_key+lmax_item))*" "+"|\n"
         ostr += (3*(lmax_key+lmax_item+4)+1)*"-"+"\n"
-        for key in self.keys():
+        for key in list(self.keys()):
             value = self[key]
             if not isinstance(value,str): value = "%f" %value
 
@@ -275,14 +275,14 @@
 
 
         #start with saving scan comments
-        for k in self.comments.keys():
+        for k in list(self.comments.keys()):
             try:
                 h5.setNodeAttr(g,k,self.comments[k])
             except:
                 print("XU.io.spectra.Save2HDF5: cannot save file comment %s = %s to group %s!" %(k,self.comments[k],name))
 
         #save scan parameters
-        for k in self.params.keys():
+        for k in list(self.params.keys()):
             try:
                 h5.setNodeAttr(g,k,self.params[k])
             except:
@@ -639,7 +639,7 @@
         self.recarray2hdf5(sg,data,"data","SPECTRA tabular data")
 
         #write attribute data
-        for k in hdr.keys():
+        for k in list(hdr.keys()):
             self.h5_file.setNodeAttr(sg,"MOPOS_"+k,hdr[k])
 
         if has_mca:
@@ -783,7 +783,7 @@
     generic
     """
 
-    fnums = range(cntstart,cntstop+1)
+    fnums = list(range(cntstart,cntstop+1))
     mcalist = []
 
     for i in fnums:
@@ -938,7 +938,7 @@
         scanlist = list([scans])
 
     angles = dict.fromkeys(args)
-    for key in angles.keys():
+    for key in list(angles.keys()):
         angles[key] = numpy.zeros(0)
     buf=numpy.zeros(0)
     MAP = numpy.zeros(0)
--- xrayutilities/math/fit.py	(original)
+++ xrayutilities/math/fit.py	(refactored)
@@ -20,7 +20,7 @@
 the odr package
 """
 
-from __future__ import print_function
+
 import numpy
 import scipy.optimize as optimize
 import time
